#!/usr/bin/env python

import os, serial, sip, sys, time

# avoid QTextStream::hex shadowing built-in function
sip.setapi('QTextStream',2)
from PyQt4.Qt import *

MAGIC = 0x42

# import command codes from Commands.h
command = None
if not os.path.exists('Commands.h'):
    print "Commands.h not found"
    sys.exit(0)
else:
    f = open('Commands.h')
    commands = {}
    for line in f:
        if line.startswith("#define COMMAND_"):
            tmp, cmd, byte = line.split()
            cmd = cmd[cmd.find('_')+1:]
            commands[cmd] = int(byte,16)
    command = type('Command', (object,), commands)

class LEDDialog(QDialog):
    rowwidth = 20
    def __init__(self, nleds, conn, parent=0):
        super(LEDDialog,self).__init__(parent)
        self.conn  = conn
        self.nleds = nleds
        self.buttons = []
        layout = QVBoxLayout()
        btnlayout = QGridLayout()
        self.btnmapper = QSignalMapper()
        for i in xrange(self.nleds):
            p = QPushButton()
            p.resize(40,40)
            self.btnmapper.setMapping( p, i)
            p.clicked.connect( self.btnmapper.map)
            self.buttons += [[p,QColor()]]
            btnlayout.addWidget(p, i/self.rowwidth, i%self.rowwidth)
        self.btnmapper.mapped['int'].connect(self.chooseColor)
        layout.addLayout(btnlayout)
        ctrllayout = QHBoxLayout()
        p = QPushButton("Refresh")
        p.clicked.connect(self.refresh)
        ctrllayout.addWidget(p)
        p = QPushButton("Set")
        p.clicked.connect(self.set)
        ctrllayout.addWidget(p)
        p = QPushButton("Close")
        p.clicked.connect(self.close)
        ctrllayout.addWidget(p)
        layout.addLayout(ctrllayout)
        self.setLayout( layout)
        self.refresh()

    def refresh(self):
        self.conn.write( bytearray( [MAGIC,command.STATE]))
        time.sleep(0.1)
        avail = self.conn.inWaiting()
        tmp = ''
        while avail > 0:
            tmp += self.conn.read(avail)
            avail = self.conn.inWaiting()
        if len(tmp) != self.nleds*3:
            print "LED strip length mismatch"
            return
        tmp = bytearray(tmp)
        for i in xrange(self.nleds):
            c = QColor(int(tmp[i*3+0]),int(tmp[i*3+1]),int(tmp[i*3+2]))
            self.buttons[i][0].setStyleSheet("background-color: rgb(%d,%d,%d)"%
                                             (c.red(),c.green(),c.blue()))
            self.buttons[i][1] = c
        
    def set(self):
        cmd = [MAGIC,command.COLOR,self.nleds]
        for b,c in self.buttons:
            cmd += [ c.red(), c.green(), c.blue() ]
        self.conn.write( bytearray( cmd))
        time.sleep(0.1)
        self.refresh()
        
    def chooseColor(self, i):
        if not i < len(self.buttons): return
        initial = self.buttons[i][1]
        c = QColorDialog.getColor(initial,self)
        if initial == c: return
        self.buttons[i][0].setStyleSheet("background-color: rgb(%d,%d,%d)"%
                                         (c.red(),c.green(),c.blue()))
        self.buttons[i][1] = c
        
class Widget(QWidget):
    #speed   = 76800
    speed   = 115200
    timeout = 100
    
    def __init__(self):
        super(Widget,self).__init__()
        self.initGUI()
        self.setInputState(False)
        self.setMinimumSize( 600, 400)
        self.timer = None
        QTimer.singleShot( 500, self.initSerial)
        
    def closeEvent(self,e):
        e.accept()
        self.closeSerial()
            
    def initSerial(self):
        self.conn = None
        ports = sorted([ os.path.join('/dev', d)
                         for d in os.walk("/dev").next()[2]
                         if d.startswith('tty.usbserial') or
                         d.startswith('ttyUSB') or
                         d.startswith('ttyAMA') ])
        self.port = ports[0] if len(ports) else None
        if not self.port:
            self.printLog("No device found")
            return
        self.printLog("Opening '%s'" % self.port)
        try:
            self.conn = serial.Serial(self.port, self.speed, timeout=1)
        except serial.serialutil.SerialException, e:
            self.printLog(str(e))
            print e
        if not self.conn:
            sys.exit(1)
        self.printLog("Opened  '%s' with speed %i" %
                      (self.port,self.conn.baudrate))
        
        retries = 10
        while retries > 0:
            if self.pingDevice():
                break
            retries -= 1
            QApplication.processEvents()
            time.sleep(1)
        else:
            print "Error connecting to device"
            sys.exit(1)
        self.printLog("Device is READY")
        self.setInputState(True)
        self.timer = self.startTimer(self.timeout)
        self.updateConfig(True)
        
    def closeSerial(self):
        if self.conn:
            self.setInputState(False)
            self.killTimer(self.timer)
            self.printLog("Sending COMMAND_RESET")
            self.conn.write( bytearray( [MAGIC, command.RESET] ))
            self.printLog("Closing '%s'" % self.port)
            self.conn.close()
            del self.conn
            self.conn = None
    
    def pingDevice(self):
        self.conn.write( bytearray( [MAGIC,command.PING] ))
        time.sleep(0.1)
        avail = self.conn.inWaiting()
        if avail and self.conn.read(avail) == "0":
            return True
        return False
        
    def reconnect(self):
        self.closeSerial()
        self.initSerial()
        
    def printLog(self, s):
        if not s.endswith("\n"): s+="\n"
        self.log.moveCursor( QTextCursor.End)
        self.log.insertPlainText(s)
        self.log.moveCursor( QTextCursor.End)
        self.log.ensureCursorVisible()
    
    def initGUI(self):
        self.inputs = []
        layout = QHBoxLayout()
        
        textLayout = QVBoxLayout()
        self.log = QPlainTextEdit()
        f = QFont("Monospace")
        f.setStyleHint(QFont.TypeWriter)
        self.log.setFont(f)
        self.log.setReadOnly(True)
        textLayout.addWidget( self.log)
        self.input = QLineEdit()
        self.input.returnPressed.connect(self.sendSerial)
        self.setFocusProxy( self.input)
        textLayout.addWidget(self.input)
        self.inputs += [self.input]
        layout.addLayout( textLayout)
 
        buttonLayout = QVBoxLayout()
        p = QPushButton("Reconnect")
        p.clicked.connect(self.reconnect)
        buttonLayout.addWidget(p)
        p = QPushButton("Rainbow")
        p.clicked.connect(
            lambda: self.conn.write( bytearray( [MAGIC,command.RAINBOW] )))
        buttonLayout.addWidget(p)
        self.inputs += [p]
        p = QPushButton("Test")
        p.clicked.connect(
            lambda: self.conn.write( bytearray( [MAGIC,command.TEST] )))
        buttonLayout.addWidget(p)
        self.inputs += [p]
        p = QPushButton("TestRaw")
        p.clicked.connect(
            lambda: self.conn.write( bytearray( [MAGIC,command.TESTRAW] )))
        buttonLayout.addWidget(p)
        self.inputs += [p]
        p = QPushButton("LED State")
        p.clicked.connect( self.getLEDState)
        buttonLayout.addWidget(p)
        self.inputs += [p]
        p = QPushButton("Conf")
        p.clicked.connect( lambda: self.updateConfig(True))
        buttonLayout.addWidget(p)
        self.inputs += [p]
        p = QPushButton("Debug")
        p.clicked.connect( self.toggleDebug)
        buttonLayout.addWidget(p)
        self.inputs += [p]
        p = QPushButton("Reset")
        p.clicked.connect(
            lambda: self.conn.write( bytearray( [MAGIC,command.RESET] )))
        buttonLayout.addWidget(p)
        self.inputs += [p]
        p = QPushButton("Set Size")
        p.clicked.connect( self.setSize)
        buttonLayout.addWidget(p)
        self.inputs += [p]
        p = QPushButton("Speed Test")
        p.clicked.connect( self.speedTest)
        buttonLayout.addWidget(p)
        self.inputs += [p]
        p = QPushButton("Free Mem")
        p.clicked.connect( self.freeMemory)
        buttonLayout.addWidget(p)
        self.inputs += [p]
        buttonLayout.addStretch(1)
        p = QPushButton("Quit")
        p.clicked.connect( self.close)
        buttonLayout.addWidget(p)
        layout.addLayout(buttonLayout)
       
        self.setLayout(layout)

    def setInputState(self,state):
        for i in self.inputs:
            i.setEnabled(state)
        if state: self.input.setFocus()
        
    def updateConfig(self, printConfig):
        self.killTimer( self.timer)
        self.conn.write( bytearray( [MAGIC,command.CONF] ))
        time.sleep(0.1)
        config = ""
        avail = self.conn.inWaiting()
        while avail > 0:
            config += self.conn.read(avail)
            avail = self.conn.inWaiting()
        try:
            d = dict([ i.strip().split(':')
                       for i in config.strip().split('\n') ])
            self.config = dict([ (k.strip(), v.strip())
                                 for k,v in d.iteritems() ])
            if printConfig: self.printLog( "Config: " + str(self.config))
        except:
            self.printLog( "Error retrieving config: " + config)
        self.timer = self.startTimer( self.timeout)
        
    def toggleDebug( self):
        self.conn.write( bytearray( [MAGIC,command.DEBUG] ))
        time.sleep(0.1)
        self.tryReadSerial(False)
        self.updateConfig(False)
        
    def speedTest(self):
        self.killTimer(self.timer)
        start = time.time()
        counter = 0
        self.conn.write( bytearray( [MAGIC,command.PING] ))
        c = self.conn.read()
        if c != "0":
                self.printLog("Error testing serial speed")
                self.timer = self.startTimer(self.timeout)
                return
        while counter < 1000:
            self.conn.write( bytearray( [MAGIC,command.PING] ))
            self.conn.read()
            counter += 1
        stop = time.time()
        elapsed = stop-start
        self.printLog("%.4f seconds per call (%.2f kHz)" %
                      (elapsed/1.e3,1./elapsed))
        self.timer = self.startTimer(self.timeout)
        
    def sendSerial(self):
        c = [ int(s,16) for s in str(self.input.text()).split(" ") ]
        s = bytearray( [MAGIC] + c)
        self.printLog( "Sending %s\n" % repr([hex(i) for i in s]))
        self.conn.write(s)
        self.input.clear()
        
    def tryReadSerial(self,printData=True):
        try:
            avail = self.conn.inWaiting()
            if avail > 0:
                s = self.conn.read(avail)
                if printData:
                    print "Read %d bytes" % avail
                    print repr(s)
                    self.printLog(s)
        except:
            self.killTimer(self.timer)
            self.setInputState(False)
            self.conn.close()
            self.conn = None
        
    def timerEvent(self,e):
        e.accept()
        self.tryReadSerial()

    def getLEDState(self):
        self.killTimer(self.timer)
        debug = False
        if self.config['loglvl'] == 'DEBUG':
            self.toggleDebug()
            debug = True
        d = LEDDialog(int(self.config['nleds']), self.conn, self)
        d.exec_()
        if debug: self.toggleDebug()
        self.timer = self.startTimer(self.timeout)

    def setSize(self):
        oldsize = int(self.config['nleds'])
        newsize = int(QInputDialog.getInt(
            self, "Set Size", "Enter Size (0-255):", oldsize, 0, 255)[0])
        if oldsize == newsize: return
        self.conn.write( bytearray([MAGIC,command.SETSIZE, newsize]))
        self.config['nleds'] = str(newsize)

    def freeMemory(self):
        self.killTimer( self.timer)
        self.conn.write( bytearray([MAGIC,command.MEMFREE]))
        time.sleep(0.1)
        s = ""
        avail = self.conn.inWaiting()
        while avail > 0:
            s += self.conn.read(avail)
            avail = self.conn.inWaiting()
            self.printLog(s)
        self.timer = self.startTimer( self.timeout)
        
def main():
    a = QApplication(sys.argv)
    w = Widget()
    w.show()
    return a.exec_()

if __name__ == '__main__':
    main()
